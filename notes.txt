it takes the bytes currently representing the ascii chars and makes binaries that follow utf8 which just a mapping from characters to bytes. for example englis ones are directly present in the ascii hence are mapped to decimals upto 128

asyncio vs sockets/threading for TCP servers:

1. Connection Handling
- Sockets/Threads: accept() in a loop, spawn a thread for each client.
- asyncio: asyncio.start_server() schedules a coroutine for each client using the event loop.

2. Request Reading
- Sockets/Threads: client_socket.recv(1024) (blocking).
- asyncio: await reader.read(1024) (non-blocking, lets other coroutines run).

3. Response Writing
- Sockets/Threads: client_socket.sendall(response.encode()) (blocking).
- asyncio: writer.write(response.encode()), await writer.drain() (async flush).

4. Connection Closing
- Sockets/Threads: client_socket.close().
- asyncio: writer.close(), await writer.wait_closed() (async close).

5. Concurrency Model
- Sockets/Threads: Each connection runs in its own OS thread (overhead, limited by system resources).
- asyncio: All connections handled by coroutines in a single thread (event loop, lightweight, scalable).

6. Error Handling
- Sockets/Threads: try/except in each thread.
- asyncio: try/except in each coroutine (async context).

Summary Table:
| Feature           | Sockets/Threads         | asyncio                        |
|-------------------|------------------------|--------------------------------|
| Accept connection | accept() + thread      | start_server() + coroutine     |
| Read request      | recv()                 | await reader.read()            |
| Write response    | sendall()              | writer.write() + await drain() |
| Close connection  | close()                | writer.close() + await wait_closed() |
| Concurrency       | OS threads             | Event loop + coroutines        |
| Error handling    | try/except             | try/except (async context)     |

Practical Note:
asyncio is ideal for high-concurrency, I/O-bound servers. It avoids thread overhead, is easier to debug, and is more scalable for many simultaneous connections.

----------------------------------------------------
HTTP SERVER IMPLEMENTATION CONCEPTS FOR INTERMEDIATE PROGRAMMERS
----------------------------------------------------

1. DATACLASSES IN PYTHON
----------------------------------------------------
Dataclasses (introduced in Python 3.7) are special classes designed to store data with minimal boilerplate code.

Key Features:
- Auto-generates __init__, __repr__, and __eq__ methods
- Simplifies class definition focused on data storage
- Fields can have default values and type hints
- Can be made immutable (frozen=True)

In our HTTP server:
```python
@dataclass
class Request:
    method: str
    path: str
    version: str
    headers: Dict[str, str] = field(default_factory=dict)
    body: bytes = b""
```

Real-world use case:
- Models HTTP requests with clean, readable code
- Provides clear structure for request data
- Avoids repetitive getter/setter code
- Simplifies debugging with auto-generated __repr__

Without dataclasses, we'd need to write:
```python
class Request:
    def __init__(self, method, path, version, headers=None, body=b""):
        self.method = method
        self.path = path
        self.version = version
        self.headers = headers or {}
        self.body = body
        
    def __repr__(self):
        return f"Request(method={self.method!r}, path={self.path!r}, ...)"
        
    # And so on...
```

2. CLASSMETHODS AS FACTORY FUNCTIONS
----------------------------------------------------
Classmethods are methods that operate on the class itself rather than instances, making them perfect for alternative constructors.

Key Features:
- Takes the class as the first parameter (cls) instead of self
- Can create and return new instances of the class
- Allows for custom object creation logic
- Simplifies complex instance creation workflows

In our HTTP server:
```python
@classmethod
async def from_reader(cls, reader: asyncio.StreamReader) -> Optional["Request"]:
    request_line_bytes = await reader.readline()
    if not request_line_bytes:
        return None
    
    request_line = request_line_bytes.decode().strip()
    method, path, version = request_line.split()
    
    # ... parse headers and body ...
    
    return cls(method, path, version, headers, body)
```

Real-world use case:
- Parses raw HTTP request data into structured objects
- Encapsulates the complex parsing logic within the class
- Creates objects from different data sources (stream readers)
- Allows asynchronous creation of objects

Example usage:
```python
# Instead of manual parsing:
request_data = await reader.readline()
method, path, version = request_data.decode().strip().split()
# ... more parsing ...
request = Request(method, path, version, headers, body)

# We can simply use:
request = await Request.from_reader(reader)
```

3. RESPONSE CLASS AND SERIALIZATION
----------------------------------------------------
The Response dataclass represents HTTP responses with a method to convert to wire format.

Key Features:
- Structured representation of HTTP response components
- Method to serialize the response to bytes for network transmission
- Encapsulates HTTP protocol details

In our HTTP server:
```python
@dataclass
class Response:
    status_code: int
    status_message: str
    headers: Dict[str, str] = field(default_factory=dict)
    body: bytes = b""

    def to_bytes(self) -> bytes:
        response_line = f"HTTP/1.1 {self.status_code} {self.status_message}\r\n"
        headers_str = "".join(f"{k}: {v}\r\n" for k, v in self.headers.items())
        return response_line.encode() + headers_str.encode() + b"\r\n" + self.body
```

Real-world use case:
- Abstracts HTTP response format details
- Ensures correct formatting of status lines and headers
- Simplifies handling of different response types
- Makes code more maintainable by separating concerns

Example usage:
```python
# Creating different responses:
ok_response = Response(200, "OK", {"Content-Type": "text/plain"}, b"Success")
not_found = Response(404, "Not Found")
created = Response(201, "Created", {"Location": "/resources/123"})

# Sending the response:
writer.write(ok_response.to_bytes())
await writer.drain()
```

4. HTTPSERVER CLASS AND ROUTING
----------------------------------------------------
The HTTPServer class manages connections and routes requests to appropriate handlers.

Key Features:
- Asynchronous connection handling with asyncio
- Request routing based on URL paths
- Handler methods for different endpoints
- Content encoding support (gzip, deflate)
- Persistent connection management

In our HTTP server:
```python
class HTTPServer:
    def __init__(self, host: str = "localhost", port: int = 4221, directory: Optional[str] = None):
        self.host = host
        self.port = port
        self.directory = directory
        
    async def start(self):
        server = await asyncio.start_server(self._handle_connection, self.host, self.port)
        async with server:
            await server.serve_forever()
            
    async def _route_request(self, request: Request) -> Response:
        if request.path == "/":
            return self.handle_root(request)
        elif request.path.startswith("/echo/"):
            return self.handle_echo(request)
        # ... other routes ...
```

Real-world use case:
- Web frameworks use similar routing mechanisms (Flask, FastAPI)
- REST APIs map endpoints to handlers
- Microservices expose specific functionality via different routes
- Content negotiation (compression, format)

Example usage:
```python
# Starting the server:
server = HTTPServer(port=8080, directory="/var/www")
asyncio.run(server.start())

# Adding a custom route (in a framework that extends this):
@server.route("/api/users")
def handle_users(request):
    return Response(200, "OK", {"Content-Type": "application/json"}, json.dumps(users).encode())
```

5. ASYNCIO FOR SERVER IMPLEMENTATION
----------------------------------------------------
asyncio enables non-blocking I/O operations for high-performance networking.

Key Features in our implementation:
- Uses asyncio.StreamReader and StreamWriter for network I/O
- Supports concurrent request handling without threads
- Handles persistent connections efficiently
- Properly manages connection lifecycle

Example from our server:
```python
async def _handle_connection(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
    try:
        while True:
            request = await Request.from_reader(reader)
            if not request:
                break

            response = await self._route_request(request)
            
            writer.write(response.to_bytes())
            await writer.drain()
            
            if request.headers.get("connection", "keep-alive").lower() == "close":
                break
    finally:
        writer.close()
        await writer.wait_closed()
```

Real-world use case:
- High-traffic web servers handling thousands of concurrent connections
- Microservices processing many requests with minimal resources
- API gateways routing requests to multiple backends
- WebSocket servers maintaining many persistent connections

6. CONTENT ENCODING AND HTTP FEATURES
----------------------------------------------------
Our server implements several HTTP/1.1 features:

Content Encoding:
```python
def _encode_body(self, body: bytes, accept_encoding: str) -> Tuple[bytes, Optional[str]]:
    encodings = [e.strip() for e in accept_encoding.split(",")]
    if "gzip" in encodings:
        return gzip.compress(body), "gzip"
    if "deflate" in encodings:
        return zlib.compress(body), "deflate"
    return body, None
```

Persistent Connections:
- Keeps connections open for multiple requests (HTTP/1.1 default)
- Checks for "Connection: close" header
- Properly closes connections when needed

File Operations:
- Reads files for GET requests
- Writes files for POST requests
- Sets appropriate content types and status codes

These implementations mirror production HTTP servers like Nginx or Apache, but in a simplified form.

7. PUTTING IT ALL TOGETHER
----------------------------------------------------
The server combines all these concepts to create a functional HTTP server:

1. User starts the server with optional directory parameter
2. Server listens for incoming connections using asyncio
3. For each connection:
   - Parse HTTP request into Request object
   - Route request to appropriate handler
   - Generate Response object
   - Apply content encoding if supported
   - Send response to client
   - Keep connection open or close based on headers
4. Handle errors gracefully and clean up resources

This pattern follows the principles of:
- Separation of concerns (parsing, routing, handling)
- Single responsibility (each class and method does one thing)
- Modularity (components can be tested independently)
- Extensibility (new routes or features can be added easily)

The resulting code is an educational example of how production HTTP servers are structured, using modern Python features to create clean, maintainable code.
